# Chap 5. 오라클 엑세스와 시스템 뷰
## 01 엑세스 절차
- 사용자가 SQL*Plust 또는 SQL Developser, Toad, Orange와 같은 툴을 실행하고 세션을 맺으려고하면, 해당 클라이언트 시스템에 유저 프로세스가 기동된다.
- 이 유저 프로세스에서 SQL문을 실행하게 되면 해당 세션 정보와 실행된 SQL 정보를 가지고 데이터베이스 서버로 해당 SQL 수행을 요청하게 된다.
    - 세션 정보를 전달하는 이유는 유저 프로세스가 하나의 DB에만 접속하는 것이 아니기 때문이다.


### 1) 서버 프로세스와 파싱(Parsing)
- 위에서 서버 프로세스를 할당 받았다면 해당 서버 프로세스에 의해 실제 SQL이 실행된다. 이때 서버 프로세스는 Shared Pool의 라이브러리 캐시에 해당 SQL에 대해 파싱을 의뢰하게 된다.

- 파싱 절차
    1. 문장 확인(Syntax Check)
    2. Semantic 확인
    3. 검색(Shared Pool Searching), 이전 파싱 정보 확인
    4. Optimization, SQL 재구성(최적화), 파싱 정보가 없다면 하드 파싱
    5. TM 락, 파싱 트리를 만들기 위해 참조 테이블에 락을 건다.

- 분석 단계 중 데이터 딕셔너리를 체크하여 참조되는 테이블, 컬럼 확인 및 권한 확인을 수행한다.

### 2) 데이터 버퍼 캐시 검색
- 파싱이 완료되면 서버 프로세스는 데이터 버퍼 캐시에서 대상 데이터를 포함하고 있는 데이터 블록을 검색한다.
- 만약 데이터 블록이 데이터 버퍼 캐시에 존재하면 해당 데이터 블록을 이용하고 존재하지 않으면 디스크에 엑세스하여 해당 데이터 블록을 데이터 버퍼 캐시에 적재한다.

### 3) 대상 집합 락(Lock) 처리
- 실제 변경을 수행하고자 하는 행에 대해 락(Lock)을 수행한다. 
- 해당 락을 TX(Transaction Exclusive)락이라 부르며 TX락은 오직 변경하는 유저만이 해당 로우를 변경할 수 있는 락이다.

### 4) 로그 기록
- Write-Ahead 로깅 기법에 의해 리두 로그 버퍼에 변경 내용을 기록하게 된다. 
- 변경 전 이미지와 변경 후 이미지로 값의 정보가 리두 로그 버퍼에 기록된다.

### 5) 변경 전 이미지 저장 준비
- 실제 변경 작업을 수행하기 전에 변경이 발생할 데이터에 대해 이전 이미지를 저장해야 한다.
- 이전 이미지를 저장하기 위해 언두 테이블스페이스의 언두 세그먼트에서 언두 블록을 할당받아야 한다.
- 이전 이미지를 저장하는 이유는 다음과 같다.
  - 롤백 수행 지원
  - 읽기 일관성 지원
  - 인스턴스 복구 수행

### 6) 변경 전 이미지 저장 및 실제 작업 수행
- 변경이 발생할 데이터에 대해 이전 이미지를 언두 블록에 저장 후 실제 작업을 수행(DML 수행)

### 7) 응답 수행
- 변경이 성공적으로 완료되면 서버 프로세스가 유저 프로세스에 응답을 보낸다.

### 8) 커밋(Commit)에 따른 변화
- 실제 커밋이 발생하면 리두 로그 버퍼에 존재하는 변경에 대한 로그를 디스크에 있는 리두 로그 파일에 기록하게 된다. 이는 빠른 커밋 아키텍쳐 때문이다. 
- 또한, 지연 쓰기에 의해 실제 데이터 버퍼 캐시에 존재하는 변경된 데이터를 바로 디스크에 저장하지 않는다.

### 9) SQL 수행에 대한 전체 개요

    1. SQL 수행: 클라이언트에서 실행하는 부분
    2. 서버 프로세스: 서버 프로세스가 요청을 받는 부분
    3. Shared Pool로 SQL 전달: 파싱을 위해 SQL을 전달
    4. 파싱
       4_1. 데이터 딕셔너리 조회: 테이블스페이스 조회
    5. Write-Ahead 로깅(Log Ahead) 기법: 데이터 변경 수행 전, 로깅 수행
    6. 해당 데이터에 TX 락: 테이블 Lock
    7. 언두 세그먼트 캐싱: 롤백을 위한 언두 블록 할당 및 데이터 버퍼 캐시에 적재
    8. DML 대상 데이터 블록 캐싱: Update 하고자 하는 데이터 블록 데이터 버퍼 캐시에 적재
    9.  이미지 복사 및 UPDATE 실행: Update 전 적재된 데이터 블록을 언두 세그먼트 블록에 복사 후 해당 데이터 블록을 Update
    10. 응답: 모든 작업이 완료되면 클라이언트에 결과 통보
    11. 커밋(COMMIT): 클라이언트에서 정상 수행을 확인하고 커밋을 수행하면 커밋 번호를 부여받고 LGWR 프로세스가 리두 로그 버퍼의 내용을 로그 파일에 기록한다.


## 02 파싱(Parsing)
- 파싱 단계 절차
  1. 문장 확인
  2. Semantic 확인
  3. 검색
  4. Optimization
  5. TM 락

### 1) 문장 확인(Syntax Check)
- 해당 구문이 정확한 구문을 이용하였는지 체크하는 절차. 문법상 오류가 없다면 해당 구문을 ASCII 코드(대소문자 구분) 값으로 변경한다. 

### 2) Semantic 확인
- 오라클은 파싱 단계 중 Semantic 확인을 수행하기 위해 데이터 딕셔너리를 확인한다.
  - 작업에 사용되는 테이블 존재 유무 확인
  - 해당 테이블에서 필요한 컬럼 존재 유무 확인
  - 해당 테이블에 대한 권한 유무 확인

- 데이터 딕셔너리 테이블
  - TAB$: 데이터베이스에 존재하는 모든 테이블 목록, DBA_TABLES(뷰 테이블)
  - COL$: 데이터베이스에 존재하는 모든 테이블의 컬럼 목록, DBA_TAB_COLUMNS(뷰 테이블)

### 3) 검색(Search)
- 해당 SQL에 대해 파싱을 수행하기 이전에 동일 SQL이 수행되었는지를 확인
- SQL문에 대한 해쉬 값을 생성하여 탐색한다.
  - 파싱 결과가 존재하지 않는다면, 하드 파싱: 파싱을 처음부터 수행 성능에서 불리
  - 파싱 결과가 존재한다면, 소프트 파싱: 파싱을 재 수행하지 않고 기존 파싱을 이용 성능에서 유리함
    - 소프트 소프터 파싱: 자주 수행하는 SQL을 PGA내의 공간에 저장해두고 PGA를 먼저 확인하여 Shared Pool 마저도 검색하지 않는 것<br>미들웨어의 Connection Pool에서 효과를 기대할 수 있다.

Connection Pool이란?

    WAS 시스템과 같은 미들웨어 시스템에서 데이터베이스에 이미 세션을 연결해 놓은 경우를 말한다. 
    하나의 미들웨어에서 Connection Pool을 복수개로 미리 연결하면 아래와 같은 장점을 가진다.
        - 데이터베이스 접속 시간 감소: 오라클의 경우에는 데이터 베이스 접속에 많은 자원을 사용하게 되므로 미리 연결해두면 사용 자원 감소 
        - 소프트 소프터 파싱 가능: 소프트 파싱보다 더 소프트(Softer)한 파싱이 가능하다. PGA 내에 파싱 정보를 가지고 있는 것

- SQL 파싱시 주의사항
- 다음과 같은 조건을 만족하지 않으면 같은 작업의 SQL이여도 하드 파싱이 일어나게 된다.
  - 대소문자 구별
  - 띄어쓰기 구별
  - 오브젝트에 대한 동일 소유자
- 리터럴 변수 사용도 하드 파싱을 수행하게 하는 원인이 될 수 있다. 가능하면 바인딩 변수를 사용하자.

### 4) Optimization
- 옵티마이저가 좀 더 좋은 실행계획을 생성하기 위해서 아래의 단계를 수행하는 것을 의미한다.
  - 내부적으로 쿼리 변형 단계: 이는 오라클 옵티마이저가 좀 더 효율적인 실행계획을 생성하기 위해 내부적으로 SQL을 변경하는 경우
  - 통계 정보 적용 단계: 데이터 딕셔너리에 수집된 통계 정보를 기반으로 최적의 실행계획을 수립할 수 있도록 통계 정보를 적용
  - 실행계획 생성 단계: 위의 통계 정보를 이용하여 여러가지 실행 계획을 생성한다. 해쉬 조인, 소트 머지 조인 및 중첩 루프 조인 등을 생성하고 가장 낮은 비용의 실행계획을 선택하여 Parsing Tree를 생성한다.

통계 정보의 개념

    규칙 기반 옵티마이저(Rule Based Optimizer): 일련의 규칙에 따라 실행계획을 생성
    비용 기반 옵티마이저(Cost Based Optimizer): 통계 정보에 따라 실행계획을 생성

## 03 시스템 뷰(System View)
### 1) 데이터 딕셔너리 뷰와 동적 성능 뷰의 차이
- 시스템 뷰는 두 가지로 구분된다.
  - 데이터 딕셔너리 뷰: 시스템 테이블스페이스에 저장되며 해당 데이터베이스에 존재하는 오브젝트 및 데이터베이스 관련 정보를 조회할 수 있음
    - DBA_ 또는 ALL_
  - 동적 성능 뷰: 메모리 상태 및 현재 세션에 대한 정보를 조회할 수 있음
    -  V$
- 테이블 딕셔너리 뷰와 뷰
  - 테이블 딕셔너리 뷰: 데이터베이스 생성 시 생성한다.
  - 뷰: 오라클의 오브젝트 중 하나이다. 실제 저장 공간을 소유하지는 않으며 뷰 정의에 대한 내용만 데이터 딕셔너리에 저장하게 된다. <br>테이블을 조회하는 SQL을 오브젝트로 생성하여 해당 뷰를 조회하면 뷰에 사용된 SQL이 수행되며 테이블을 조회하게 된다.

### 2) 데이터 딕셔너리 뷰의 구분
- 데이터 딕셔너리 뷰는 3가지로 구분할 수 있다.
  
구분|내용|예제
:---:|---|---
DBA_|해당 데이터베이스에 존재하는 모든 내용 조회 가능|DBA_TABLES
ALL_|해당 유저에게 권한이 존재하는 모든 내용 조회 가능|ALL_TABLES
USER_|해당 유저가 소유자(Owner)로 되어 있는 모든 내용 조회 가능|USER_TABLES

데이터 딕셔너리 뷰의 예

    SQL> SELECT * FROM DBA_SEGMENTS;
    SQL> SELECT * FROM ALL_SEGMENTS;
    SQL> SELECT * FROM USER_SEGMENTS;

구분|내용|데이터 양
:---:|---|:---:
DBA_SEGMENTS<br>데이터 딕셔너리 뷰|해당 데이터베이스에 존재하는 모든 세그먼트 정보를 저장|가장 많음
ALL_SEGMENTS<br>데이터 딕셔너리 뷰|유저가 엑세스할 수 있는 권한을 가지는 모든 세그먼트에 대해 조회 가능|중간
USER_SEGMENTS<br>데이터 딕셔너리 뷰|유저가 소유하고 있는 모든 세그먼트의 정보를 조회 가능|가장 적음

## 04 데이터 딕셔너리 뷰의 종류
- 데이터 딕셔너리 뷰는 다음과 같은 종류가 존재한다
    - 오브젝트 관련 데이터 딕셔너리 뷰
    - 유저 및 권한 관련 데이터 딕셔너리 뷰
    - 스토리지 관련 데이터 딕셔너리 뷰
    - 기타 데이터 딕셔너리 뷰

### 1) 오브젝트 관련 데이터 딕셔너리 뷰
데이터 딕셔너리 뷰 이름|내용
:---:|---
DBA_OBJECTS|데이터베이스에 존재하는 모든 오브젝트 정보
DBA_SEGMENTS|데이터베이스에 모든 오브젝트 중 세그먼트에 대한 정보
DBA_TABLES|데이터베이스에 존재하는 모든 테이블 목록 및 정보
DBA_INDEXES|데이터베이스에 존재하는 모든 인덱스 목록 및 정보
DBA_TAB_PARTITIONS|데이터베이스에 파티션 테이블이 존재할 경우에 조회 가능
DBA_TAB_SUBPATITIONS|데이터베이스에 존재하는 파티션 중 결합 파티션 테이블이 존재한다면 조회 가능
DBA_VIEWS|데이터베이스에 존재하는 모든 뷰 목록 및 정보
DBA_TRIGGERS|데이터베이스에 존재하는 모든 트리거 목록 및 정보
DBA_SYNONYMS|데이터베이스에 존재하는 모든 동의어 목록 및 정보
DBA_DB_LINKS|데이터베이스에 존재하는 모든 데이터베이스 링크 정보

오브젝트와 세그먼트

    오브젝트 중 스토리지 영역을 가지는 오브젝트를 세그먼트라 한다. 
    예를 들어 테이블과 인덱스는 오브젝트이면서 세그먼트이지만 뷰와 시퀀스 등은 스토리지 영역 없이 정의만 되므로 단지 오브젝트에만 해당된다.

### 2) 유저 및 권한 관련 데이터 딕셔너리 뷰
데이터 딕셔너리 뷰 이름|내용
:---:|---
DBA_USERS|데이터베이스에 존재하는 모든 유저에 대한 정보
DBA_TS_QUOTAS|유저별로 테이블스페이스에 할당된 공간을 확인할 수 있으며, MAX_BYTS 컬럼이 1의 값이면 공간 사용 제한이 없다는 의미
DBA_TAB_PRIVS|유저 또는 롤 별로 테이블에 대한 권한 부여 현황 확인 가능
DBA_SYS_PRIVS|유저 또는 롤 별로 부여된 시스템 권한 확인 가능
DBA_ROLES|데이터베이스에 존재하는 모든 롤 확인 가능
DBA_ROLE_PRIVS|유저 및 롤에 할당된 롤 확인 가능

롤

    롤이란 유저의 권한 관리를 보다 편리하게 수행하기 위해 만들어진 오브젝트이다.
    해당 롤을 유저에게 부여하면 해당 유저는 롤에 부여된 모든 권한을 할당받게 된다.

### 3) 스토리지 관련 데이터 딕셔너리 뷰
데이터 딕셔너리 뷰 이름|내용
:---:|---
DBA_TABLESPACES|데이터베이스에 존재하는 모든 테이블스페이스에 대해 조회 가능
DBA_SEGMENTS|데이터베이스에 존재하는 오브젝트 중 스토리지를 가지는 모든 세그먼트 조회 가능
DBA_EXTENTS|각 세그먼트별로 할당된 익스텐트에 대해 조회 가능
DBA_DATA_FILES|각각의 테이블스페이스를 구성하는 데이터 파일의 정보 확인 가능
DBA_TEMP_FILES|지역 관리 임시 테이블스페이스에 대한 임시 파일 정보 확인 가능
DBA_FREE_SPACE|테이블스페이스별로 사용 가능 여유 공간 확인 가능

### 4) 기타 데이터 딕셔너리 뷰
데이터 딕셔너리 뷰 이름|내용
:---:|---
DBA_TABL_COLS|테이블을 구성하는 모든 컬럼 정보 확인 가능
DBA_IND_COLUMNS|테이블에 생성되어 있는 인덱스들의 컬럼 구성 정보 확인 가능
DBA_PART_KEY_COLUMNS|파티션 테이블에 대해 파티션 키 컬럼 확인 가능
DBA_TAB_PARTITIONS|테이블 파티션에 대한 HIGH VALUE, 파티션 저장 영역 등에 대한 정보 확인 가능
DBA_PART_TABLES|테이블의 파티션 형태(LIST, HASH, RANGE)를 확인할 수 있다.

## 05 동적 성능 뷰 종류
- 동적 성능 뷰는 3가지 종류가 존재한다.
  - 세션 관련
  - 대기 이벤트 관련
  - 기타

### 1) 세션 관련 동적 성능 뷰
- 세션에 관련된 동적 성능 뷰는 실제 업무에 많이 사용되므로 많이 조회해 보는 것이 중요하다.

동적 성능 뷰 이름|내용
:---:|---
V$TRANSACTION|현재 언두 데이터를 사용하는 모든 작업에 대해 실시간 조회가 가능. <br>언두 데이터를 사용하는 작업이므로 현재 수행되고 있는 모든 DML 작업이 해당 동적 성능 뷰에서 조회 가능
V$SESSION|현재 데이터베이스에서 작업을 수행하거나 또는 수행을 하지 않더라도 접속해 있는 모든 세션의 정보
V$PROCESS|데이터베이스에 접속한 운영 체제 프로세스 별로 하나의 로우씩 추출된다.
V$SQL|수행된 SQL을 조회할 수 있다.
V$SQL_PLAN|각각의 SQL에 대한 실행계획을 조회할 수 있다.

현재 세션별로 수행되고 있는 모든 SQL을 추출하는 쿼리

    SQL> SELECT S.SID, Q.SQL_TEXT
           FROM V$SESSION S, V$SQL Q
          WHERE S.SQL_ID=Q.SQL_ID
            AND S.STATUS='ACTIVE';

- 동적 성능 관리 뷰를 조인하기 위한 조인 컬럼

동적 성능 뷰 이름|조인 컬럼1|조인 컬럼2|조인 컬럼3|조인 컬럼4
:---:|---|---|---|---
V$PROCESS||ADDR||
V$SESSION|SADDR|PADDR|TADDR|SQL_ID
V$TRANSACTION|SES_ADDR||ADDR|
V$SQL||||SQL_ID
V$SQL_PLAN||||SQL_ID

### 2) 대기 이벤트 관련 동적 성능 뷰
- 어떤 SQL이 작업을 수행하지 못하고 대기하는 순간 발생되는 이벤트이다. 대기 이벤트를 효과적으로 분석하는 것은 시스템의 성능을 향상시키는데 많은 도움이 된다.

동적 성능 뷰 이름|내용
:---:|---
V$SESSION_WAIT|현재 세션에서 발생하고 있는 대기 이벤트 확인 가능
V$EVENT_NAME|해당 뷰는 동적 성능 뷰는 아니지만, 동적 성능 뷰에서 발생하는 모든 이벤트에 대한 정보를 저장하고 있음
V$SESSION_EVENT|현재 데이터베이스에 접속해 있는 세션들의 대기 이벤트 값의 누적 값을 저장
V$SYSTEM_EVENT|기동 이후 대기 이벤트에 대한 모든 누적 값을 확인 가능

### 3) 기타 동적 성능 뷰
동적 성능 뷰 이름|내용
:---:|---
V$DATABASE|데이터베이스 생성 시간 및 LOG_MODE등 기본적인 정보를 제공
V$INSTANCE|STARTUP TIME, 인스턴스 이름, HOSTNAME 등 인스턴스의 기본 정보 제고
V$SGASTAT|해당 데이터베이스의 메모리 정보 확인 가능
V$BACKUP|해당 데이터베이스의 모든 데이터 파일에 대해 백업 여부 확인 가능
V$LOCK|현재 데이터베이스에 수행중인 모든 락(Lock) 정보 확인 가능
V$PARAMETER|현재 데이터베이스에 설정된 파라미터 값 확인 가능

V$BACKUP, V$LOCK 동적 성능 뷰

    V$BACKUP 동적 성능 뷰의 STATUS 값이 ACTIVE라면 현재 온라인 백업이 수행중이라는 의미 또한 DATE 컬럼은 최근 ACTIVE 상태였던 일자를 뜻함
    V$LOCK 동적 성능 뷰는 오라클 버전이 높아지면서 엑세스하는 부하가 증가하였다. 이런 이유로 점점 엑세스 하기 힘든 동적 성능 뷰이다.