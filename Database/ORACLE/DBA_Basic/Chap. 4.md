# Chap 4. 오라클 프로세스
## 01 오라클 프로세스 개념 및 종류
- SGA와 프로세스는 서로 통신을 하며 작업을 수행하기 위해 반드시 필요한 요소이다.

<img src=https://t1.daumcdn.net/cfile/tistory/266F3A3754F9FE3120 />

종류|내용
:---:|---
유저<br>프로세스|데이터베이스에 접속해서 작업을 할 수 있도록 도와주는 프로세스, 예를들어 SQL\*PLUS로 DB에 접속하면 SQL\*PLUS는 유저 프로세스를 생성한다. 
서버<br>프로세스|- 유저 프로세스의 요청을 처리하기 위해 서버 프로세스가 존재한다.<br>- 유저 프로세스가 SQL과 세션 정보를 가지고 데이터베이스에 요청하게 되면 데이터베이스로부터 서버 프로세스 하나를 할당받게 된다.
백그라운드<br>프로세스|- 오라클 메모리 구조인 SGA 관리 등의 내부적인 작업 수행을 위해 필요한 프로세스이다.<br>- 특정 기능을 사용하기 위해서는 해당 기능을 지원하는 프로세스를 미리 기동시켜야한다.<br>- 서비스 중에는 지속적으로 프로세스가 기동되어 있어야 하기 때문에 이를 백그라운드 프로세스라고 한다.<br>- 백그라운드 프로세스는 여러 개가 존재하며, 각각의 프로세스들은 역할에 맞는 작업을 지속적으로 수행한다.
- 데이터베이스에 접근하여 업무를 수행하는 미들웨어(WAS 등)도 데이터베이스 프로세스 구조 측면에서는 유저 프로세스이다.

- 백그라운드 프로세스의 구분

구분|내용
:---:|---
필수 백그라운드<br>프로세스|데이터베이스가 구동되어 운영되기 위해 반드시 필요한 관리 프로세스, 해당 프로세스 중 하나라도 문제가 생기면 데이터베이스는 Shutdown된다.
선택 백그라운드<br>프로세스|특정 기능을 사용하기 위해 필요한 프로세스, 기능적 요구에 의해 선택되어 생성된다. <br>해당 프로세스가 정지되면 해당 기능은 사용이 불가하고 어떤 프로세스들은 정지되면 데이터베이스가 Shutdown 되기도 한다.

## 02 데이터 베이스 기록자 백그라운드 프로세스(Database Writer, DBWR)
DBWR란?

    메모리에서 변경된 더티 버퍼를 디스크에 기록하는 프로세스

<img src=https://t1.daumcdn.net/cfile/tistory/246EFA3754F9FE321F />

### 1) DBWR의 역할
구분|내용
:---:|--
더티 버퍼|변경은 완료되었지만 디스크에 기록되지 않은 버퍼
Pinned 버퍼|변경 중인 버퍼로 해당 버퍼를 사용하고자 하는 다른 세션은 대기
Free/Unused 버퍼|인스턴스가 시작된 직후 비어있는 상태의 버퍼
Clean 버퍼|변경이 완료된 후 디스크에 기록된 버퍼로 재기록될 수 있는 상태의 버퍼

- DBWR 백그라운드 프로세스에 의해 디스크로 쓰여진 기록된 버퍼는 Clean 버퍼로 상태가 변경된다.
- 인스턴스의 Crash 현상
  - 데이터베이스 사용 중 비정상 종료로 메모리의 내용이 저장되지 않고 없어지는 경우를 말한다. 이러한 경우 메모리에 있는 변경된 버퍼 캐시의 내용은 손실되지만, 디스크에 기록된 데이터는 온전히 보전된다.

- 메모리 히트율
  - 디스크보다 메모리에서 엑세스 하는 비율이 높아지게 되면 Buffer Cache Hit 율이 높아지며 이를 메모리 히트율이 좋다고 표현한다.

### 2) DBWR의 특징

항목|내용
:---:|---
지연 쓰기<br>(Deffered Write)|데이터 버퍼 캐시로 복사된 데이터 블록이 변경될 경우 해당 데이터 블록을 변경 즉시 데이터 파일에 기록하지 않고, 추후 여러 개의 변경 작업을 모아서 한 번에 디스크에 저장, 빈번한 디스크 I/O 방지
빠른 커밋<br>(Faster Commit)|지연 쓰기 방식으로 변경된 데이터를 디스크로 기록할 경우 장애가 발생했을 때 메모리에만 저장되어 있던 변경 정보가 유실되어 데이터 정합성에 문제가 발생하게 된다.<br> 빠른 커밋이란 데이터 변경을 완료하고 커밋을 수행하면 변경된 내용을 즉시 디스크에 기록하지 않고 변경에 대한 로그 정보를 즉시 디스크로 기록하는 방법이다.

- 버퍼의 순환
  - Free 버퍼 --(DML 수행)--> Pinned 버퍼 --(변경 완료)--> 더티 버퍼 --(DBRW에 의한 디스크 저장)--> Clean 버퍼 ... (반복)
  
<img src=https://t1.daumcdn.net/cfile/tistory/266F233754F9FE321F />

### 3) DBWR의 활동 주기
- DBWR은 지연 쓰기에 의해 더티 버퍼에 대해서 즉시 디스크로 적용하지 않게 된다. 그럼 어느 기점에 버퍼를 디스크로 적용하는지 확인해보자.

<img src=https://t1.daumcdn.net/cfile/tistory/276F7D3754F9FE321F />

항목|내용
:---:|---
체크포인트가<br>발생했을 경우|CKPT 프로세스에 의해 발생
더티 버퍼의 수가<br>임계치에 도달했을 경우|데이터 버퍼 캐시내의 모든 버퍼 중 일정 수 이상의 버퍼가 더티 버퍼로 변경되어 있을 때 더티 버퍼를 디스크에 저장
일정한 수의 버퍼를<br>검색하고도 Clean/Free 버퍼를<br>찾지 못했을 경우|전체 버퍼를 다 검색하는 것이 아니라 일정 개수의 버퍼를 검색한 후에도 Clean/Free 버퍼를 찾지 못했다면 더티 버퍼를 디스크에 저장
테이블스페이스가<br>오프라인 또는<br>읽기 전용 모드로<br>변경될 경우|이러한 경우는 해당 테이블 스페이스에 존재하는 데이터에 대해 변경 작업을 제한하겠다는 의미이므로,<br> 테이블 스페이스의 상태가 변경되기 전에 데이터 블록에 변경작업이 완료되었으나 디스크에 저장되지 않은 해당 테이블스페이스의 더티 버퍼를 디스크에 저장
테이블이 DROP되거나<br>TRUNCATE될 경우|앞의 테이블스페이스 오프라인 및 읽기 전용과 같은 상황
테이블스페이스에<br>온라인 백업 명령이<br>수행될 경우|온라인 백업을 수행하게되면 디스크에 존재하는 해당 테이블스페이스의 데이터 파일을 복사하게 된다. 따라서 변경된 더티 버퍼들을 디스크에 쓴다.
주기적인<br>타임아웃에 의해 발생|오라클이 내부적이 시간을 설정하여 더티 버퍼들을 디스크에 저장한다.
- 주기적인 타임아웃에 의한 체크포인트
  - 주기적인 타임아웃에 의한 체크 포인트는 더티 버퍼에 대한 정보만을 디스크에 기록하는 것이다. 실제 더티 버퍼를 디스크에 쓰는 것이 아니라 더티 버퍼의 정보를 쓰는 것이라 성능에 영향이 없다.

### 다중 DBWR 백그라운드 프로세스
- DBWR은 여러 개 존재할 수 있으며, 하나의 DBWR에 대해 여러개의 I/O 슬레이브 프로세스를 기동시킬 수 있다.

<img src=https://t1.daumcdn.net/cfile/tistory/226F4A3754F9FE331F />

## 03 로그 기록자 백그라운드 프로세스(Log Writer, LGWR)
LGWR란?

    리두 로그 버퍼에 기록된 내용을 어떤 주기나 조건에 의해 리두 로그 파일에 기록하는 프로세스

<img src=https://t1.daumcdn.net/cfile/tistory/2478A53E54F9FE9535 />

### 1) LGWR의 역할
항목|내용
:---:|---
빠른 커밋<br>(Fast Commit)|특정 DML 작업을 수행하고 커밋을 수행한 직후 데이터베이스에 변경된 데이터 블록을 저장하는 것이 아니라 리두 로그 파일에 변경 내용을 기록한다. 
Write-Ahead<br>(Log Ahead)|DML 작업을 수행할 경우 실제 데이터에 대해 DML을 수행하기 전에 데이터들의 변경에 대한 내용을 리두 로그 버퍼에 미리 저장하는 것.
동시 쓰기|커밋 시 로그를 기록하는 부분에서 같은 시점에 커밋되는 작업들에 대해서는 동시에 리두 로그 파일에 기록하는 것.

### 2) 빠른 커밋(Fast Commit)
항목|내용
:---:|---
더티 버퍼를 디스크의<br>데이터 파일에 즉시<br>기록하지 않는 이유|각각의 변경된 데이터 블록은 디스크에 적용될 위치가 정해져 있으므로 모든 변경된 데이터 블록을 실시간으로 정해진 위치에 기록하게 되면,<br> 디스크 위치 검색하는 부분과 변경된 데이터가 저장되어 있는 데이터 블록 단위로 I/O가 발생하여 극심한 속도저하 발생.
실제 변경 블록을<br>디스크에 즉시 기록하지 않고<br>데이터 정합성을<br>보장하고 복구를 하는 방법|성능 저하의 이유로 DBWR은 지연 쓰기를 지원하게 된다. 그러나 커밋된 내용은 커밋 수행 후 즉시 적용되어 장애 발생 시에는 복구가 수행되어야 한다.<br>이는 Write-Ahead 기법에 의해 리두 로그 버퍼에 기록된 변경 내용을 커밋과 동시에 리두 로그 파일에 저장함으로써 해결한다.

- 빠른 커밋의 장점
  - DBWR가 데이터 버퍼 캐시의 변경된 데이터 블록을 디스크에 쓰는 것 보다 LGWR가 리두 로그 버퍼의 로그를 리두 로그 파일에 쓰는 속도가 더 빨라 시스템의 부하를 감소시킨다.
  - 오라클은 데이터 블록 단위로 I/O가 일어나므로 행 하나만 변경되어도 블록 전체를 기록해야한다. 리두 로그 버퍼는 블록 전체가 아닌 변경된 부분만을 기록하므로 적은 디스크 I/O를 발생시킨다.
  - 커밋 시 최소 단위의 내용만 기록한다. 또한, 변경 내용만 저장하여 크기가 작으며 순차적으로 파일에 기록되므로 변경하는 데이터의 양이 커밋 완료 속도에 영향을 미치지 않는다.

- DBWR는 데이터 블록 전체를 기록하고 기록해야하는 위치가 정해져있다. LGWR는 변경된 부분만 기록하고 위치에 상관없이 순차적으로 기록한다. LGWR이 DBWR보다 기록하는 속도가 더 빠르다.

### 3) 동시 쓰기
- 디스크 I/O 횟수를 감소시킴으로써 성능 향상
- 리두 로그 파일에 로그를 기록할 때 같은 시간에 커밋된 모든 트랙잭션의 로그를 동시에 기록하게 된다.

<img src=https://t1.daumcdn.net/cfile/tistory/226EF23754F9FE311F style='background-color:#FFFFFF' />

### 4) LGWR의 활동 주기

<img src=https://t1.daumcdn.net/cfile/tistory/2151073954F9FE3532 />

- 커밋을 수행할 경우
- DBWR에 의해 변경된 데이터 블록을 저장하기 전
- 리두 로그 버퍼의 1/3 이상 사용
- 1MB 이상의 리두 로그 생성 시
- 3초마다(타임아웃)

---
# 질문
- 동시 쓰기는 트랜잭션이 여러번 일어나서 리두 로그 버퍼에 변동 사항이 기록되더라도 LGWR가 작동하지 않다가 LGWR이 상기 5가지 경우에 리두 로그 버퍼의 내용을 디스크에 쓸때 버퍼의 내용을 전부 동시에 쓴다는 의미인가요?
---

## 04 프로세스 모니터 백그라운드 프로세스(Process Monitor, PMON)
PMON이란?

    인스턴스의 모든 프로세스를 감시하고 실행이 정지된 프로세스의 복구를 수행한다. 
    유저 또는 서버 프로세스가 비정상 종료될 경우 프로세스 복구를 수행하고 데이터 버퍼 캐시를 정리하며,
    서버 프로세스가 사용하던 자원(PGA와 Lock 등)을 해제한다.

<img src=https://t1.daumcdn.net/cfile/tistory/21457E4154F9FF2F24 />

- PMON 프로세스의 역할
  - 실패한 프로세스가 수행 중이던 트랜잭션 롤백 및 해당 프로세스의 메모리 락 기타 자원 할당 해제
    - PMON 프로세스는 다른 프로세스에 의해 호출되어 활동하며 서버 프로세스가 작업을 수행하는 중 실패 또는 비정상 종료한 경우 수행 된다.
  - Idle 세션 타임아웃에 대한 모니터링
    - Idle 세션에 대한 일정 시간 이후에 타임아웃을 수행하나.

## 05 시스템 모니터 백그라운드 프로세스(System Monitor, SMON)
SMON이란?

    비정상으로 종료한 인스턴스가 재시작될 때 복구를 수행하며 사용하지 않는 임시 세그먼트를 정리한다.

<img src=https://t1.daumcdn.net/cfile/tistory/27448B4154F9FF3026 />

- 인스턴스 복구 수행
- 데이터 블록의 연속된 공간 통합
- 임시 세그먼트 제거

### 1) 인스턴스 복구 수행
- 인스턴스 복구 
  - 데이터베이스 비정상 종료 후 재 시작될 때 리두 로그 파일의 로그 정보를 엑세스하여 데이터 파일에 기록되지 않은 이전에 커밋된 데이터를 복구하게 된다.

- 비정상 종료로 인한 메모리 영역 제거 시 인스턴스 복구 절차
    1. LGWR이 리두 로그 파일에서 로그를 읽어온다.
    2. 읽어온 로그 파일을 통해 커밋이 수행된 작업과 수행되지 않은 모든 작업이 데이터베이스에 적용된다. (롤 포워드, Roll Forward)
       <br>2_1. 실제 SQL을 수행하므로 언두 세그먼트에는 롤백을 위해 로그 파일을 적용한 데이터가 재구성된다.
    3. 롤 포워드 작업에 의해 커밋이 수행된 작업은 DBWR이 디스크에 저장하고 동일한 내용을 데이터 버퍼 캐시에 저장(롤백)한다. 데이터 버퍼 캐시를 장애 발생 직전의 상태(Commit은 기록하고)로 유지한다.

롤 포워드란?

    오라클 비정상 종료 후 재기동하게 되면 리두 로그 파일에 있는 내용을 해당 데이터베이스에 적용하는 과정이며 
    실제 리두 로그에 있는 SQL을 수행하게 되므로 롤백을 위한 언두 세그먼트가 구성됨.

- 인스턴스 복구
  - 인스턴스 복구는 롤 포워드 + 롤백

항목|내용
:---:|---
롤 포워드<br>(Roll Forward)|커밋 유무에 상관없이 모든 변경 데이터를 데이터베이스에 적용<br>(실제 SQL을 수행하므로 언두 세그먼트 재구성)
롤백<br>(Rollback)|롤 포워드에 의해 적용된 변경 작업 중 커밋된 작업을 제외한 다른 작업은 롤백<br>(롤 포워드 단계에서의 언두 세그먼트 재구성을 이용하여 롤백)

### 2) 데이터 블록의 연속된 공간 통합

<img src=https://t1.daumcdn.net/cfile/tistory/227E133E57EA22CB03 />

- A 테이블이 삭제된 후 B 테이블이 추가로 4개의 데이터 블록으로 구성된 익스텐트를 할당 받으려면 사용하지 않는 연속된 4개의 공간이 있어야 한다.
- 그림에서는 비어있는 공간이 있음에도 구분선에 의해 연속된 공간이 존재하지 않기 때문에 B 테이블이 추가로 4개 데이터 블록을 할당받을 수 없다. 이는 테이블을 제거하더라도 구분선은 제거되지 않아 발생하는 문제이다.
- SMON은 이러한 구분선에 의해 끊어진 공간으로 인식하는 데이터 블록들을 하나의 공간으로 통합한다.

---
# 질문 
### 1. 3단원 오라클 메모리의 Redo Log Buffer 파트 Less log 옵션 중 append에서 말씀해주셨던 칸막이가 여기에서 나오는 구분선 인가요? 
### 2. append 옵션을 주면 저런 구분선을 만들지 않아 성능이 좋아지는 것인가요?
---

### 데이터 블록의 연속된 공간 통합의 효용성
- SMON 프로세스의 기능인 공간 통합 기능은 통합해야할 양이 많다면 해당 작업에 의해 매우 큰 부하를 발생시킬 수 있기 때문에 해당 공간 통합 역할을 매우 낮은 수준까지만 지원한다.
- 따라서 공간 통합이 수행되지 않는 경우도 발생하며, 이러한 경우 수동으로 통합해야한다.

`SQL> ALTER TABLESPACE TEST COALESCE;`

- 공간 통합이 발생하지 않게 구성 하는 방법
  - 동일한 익스텐트 크기로 구성: 저장된 모든 세그먼트의 익스텐트 크기가 동일하다면 구부 선에 관계없이 할당 가능
  - 지역 관리 테이블스페이스 이용: 지역 관리 테이블스페이스는 해당 테이블스페이스 내에 모든 세그먼트 익스텐트으 ㅣ크기를 동일하게 구성하게 되므로 위와 동일

### 3) 임시 세그먼트 제거
- 과거 버전에서 사용하던 롤백 세그먼트의 OPTIMAL 크기를 유지하기 위해 12시간에 한번씩 롤백 세그먼트를 축소하는 작업을 수행하게 된다.

## 06 체크포인트 백그라운드 프로세스(Checkpoint, CKPT)
체크포인트란?

    데이터 버퍼 캐시의 변경된 데이터 블록을 데이터 파일에 기록하여 메모리 내의 데이터와 데이터 파일에 저장된 데이터를 일치시키는 작업

<img src=https://t1.daumcdn.net/cfile/tistory/2406873657EA298F37 />

### 1) CKPT 절차 및 활동 주기
- 체크포인트 큐는 변경된 데이터 블록의 주소 값을 저장하고 있으며 체크 포인트가 발생하면 체크포인트 큐 안에 존재하는 변경된 데이터 블록인 더티 버퍼를 DBWR 백그라운드 프로세스가 데이터 파일로 기록하게 된다. 
- 체크포인트가 발생하면 컨트롤 파일과 모든 데이터 파일 헤더에 체크포인트 번호를 갱신하게 된다.

체크포인트 번호란?

    데이터의 정합성을 비교하는 기준이다. 해당 체크포인트 번호는 컨트롤 파일과 모든 데이터 파일 헤더에 지속적으로 기록되고 만약 데이터베이스 오픈 시에 해당 체크포인트 번호가 일치하지 않으면 복구 절차를 수행해야만 오픈된다.

- 로그 스위치가 발생할 경우
- 3초마다 발생
- 테이블스페이스가 오프라인으로 변경될 경우
- 데이터베이스가 정상 종료될 경우
- 사용자가 `ALTER SYSTEM CHECKPOINT` 명령으로 명시적인 체크포인트를 발생시킬 경우
- 체크포인트 관련 파라미터에서 정한 값에 의해 활동 주기가 되었을 경우

로그 스위치란?

    현재 사용 중인 리두 로그 파일에서 다른 리두 로그 파일로 로그를 기록하는 현상, 이 경우 전체 체크포인트가 발생

- `FAST_START_MTTR_TARGET` 파라미터는 인스턴스 복구 시 실제 복구에 소요되는 시간을 초단위로 설정하는 파라미터이며, 이 시간 이상 소요될 양의 변경된 데이터 블록이 메모리에 존재한다면 체크포인트를 발생시키겠다는 뜻과 동일하다.

- 복구와 성능

항목|장점|단점
:---:|---|:---:
체크포인트 주기가<br>짧은 경우|인스턴스 복구는 마지막 체크포인트 이후부터 진행되기 때문에 주기가 짧은 경우<br>적용할 리두 로그 정보가 감소한다. 따라서 복구 시간이 적게 소요된다.|변경된 데이터 블록을 자주 파일로 기록하므로 잦은 디스크 I/O 발생
체크포인트 주기가<br>긴 경우|체크포인트가 자주 발생하지 않는다면 디스크 I/O 감소로 체크포인트에 의한 성능 저하 감소|인스턴스 복구 시 더 많은 시간이 소요

## 07 기타 백그라운드 프로세스
### 1) ARCH(Archiver)
- 리두 로그 파일의 아키텍쳐중 하나가 해당 리두 고르 파일을 재사용한다는 점이다.
- 이 뜻은 리두 로그 파일을 다 사용한 후에 다른 리두 로그 파일을 사용하게되고, 모든 리두 로그 파일을 사용한 후에는 처음의 리두 로그 파일을 사용하므로 기존 로그 정보는 지워지게 된다.
- 따라서 복구를 위해 리두 로그 파일이 지워지기 전에 백업을 수행해야하며, 이는 ARCH 백그라운드 프로세스가 수행하게 된다.

- ARCH 백그라운드 프로세스의 기동 조건
    1. 아카이브 로그 모드 필요
    2. 리두 로그 파일에 대한 백업 공간 필요

- ARCH 백그라운드 프로세스는 다음과 같은 경우 작동한다.
    1. 로그 스위치가 발생하여 기존 리두 로그 파일을 아카이브 로그 파일로 생성해야할 경우
    2. 장애 복구 시 아카이브 파일을 사용할 경우

### 2) CJQ0(Coordinator Job Queue)와 Jnnn
- 정기적인 작업에 대해 스케줄링하여 자동으로 수행하게 하는 프로세스가 CJQ0 백그라운드 프로세스이다.
- CJQ0 프로세스는 계획된 작업을 실행시키는 역할을 수행하며, 실제 작업은 Jnnn 백그라운드 프로세스가 수행한다. <br>(JOB_QUEUE_PROCESSES 파라미터로 동시에 최대 1000개까지 운용 가능)

### 3) Pnnn(Parallel Query Slaves)
- 대용량의 작업을 병렬 처리로 수행하게 되면 기동되는 백그라운드 프로세스

- 백그라운드 프로세스를 지정하는 파라미터
    1. PARALLEL_MAX_SERVERS: 하나의 시스템에서 최대 사용할 수 있는 Pnnn 프로세스 수를 지정
    2. PARALLEL_MIN_SERVERS: 해당 데이터베이스가 기본적으로 사용할 병렬 처리 백그라운드 프로세스의 수

### 4) RECO(Recoverer)
- 분산 데이터베이스 환경에서 한 개 이상의 데이터베이스에 연결되어 문제가 발생한 트랜잭션이 사용하던 테이블 또는 행에 수행된 락을 해제하는 역할

### 5) Snnn과 Dnnn
- 오라클 Shared 서버 환경에서 사용하는 백그라운드 프로세스이다. 
  - Snnn: 공유 서버 프로세스
  - Dnnn: 디스페처 프로세스