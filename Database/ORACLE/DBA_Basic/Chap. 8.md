# Chap 8. 리두 로그 파일과 아카이브 로그 파일
## 01 리두 로그 파일의 개념

<img src=https://t1.daumcdn.net/cfile/tistory/265A813354FA050E2D />

리두 로그 버퍼란?

    데이터베이스 장애 시 복구를 수행하기 위해 모든 DML에 대한 로그를 기록, LGWR에 의해 리두 로그 파일로 저장 

리두 로그 파일이란?

    - 리두 로그 버퍼의 내용을 디스크에 기록하는 데이터베이스 구성 요소
    - 리두 로그 버퍼가 재사용되므로 재사용되기 전에 복구를 위해 변경 내용을 디스크에 저장

### 1) 리두 로그 파일의 구성 요소

<img src=https://t1.daumcdn.net/cfile/tistory/275A9D3354FA050F2E />

항목|목적
:---:|---
리두 로그 멤버|리두 로그 버퍼의 내용을 기록하는 파일이며 하나의 리두 로그 멤버는 하나의 리두 로그 파일이다. <br>LGWR은 리두 로그 버퍼의 내용을 동일 그룹에 속해있는 모든 리두 로그 멤버에 동일한 내용들을 기록
리두 로그 그룹|동일한 로그 기록을 저장하고 있는 리두 로그 멤버들의 집합

- Current 리두 로그 그룹: 여러개의 리두 로그 그룹 중 현재 LGWR 프로세그가 리두 로그 버퍼의 내용을 기록하는 리두 로그 그룹을 의미

- 로그 스피닝, 로그 스위치

용어|내용
:---:|---
로그 스피닝<br>(Log Spinning)|리두 로그 순환을 반복하여 모든 그룹을 사용하고 다시 처음의 리두 로그 그룹의 멤버에 로그를 기록하는 현상
로그 스위치<br>(Log Switch)|LGWR 프로세스는 리두 로그 버퍼의 내용을 Current 리두 로그 그룹의 리두 로그 멤버에 기록하다가 여유 공간이 부족하면 Next 리두 로그 그룹에 기록하게 된다. 이렇게 Current -> Next로 변경하는걸 로그 스위치라 한다.

- 로그 스위치시 수행하는 작업
    - 로그 시퀀스 번호 증가
    - CKPT 백그라운드 프로세스에 의해 체크포인트 수행
    - 아카이브 로그 모드라면 리두 로그 파일에 대한 아카이브 발생

- 로그 스위칭 단계
    1. 컨트롤 파일을 확인하여 다음에 사용될 리두 로그 그룹 번호를 확인하고, 다음 리두 로그 그룹이 체크포인트와 아카이브 모드에서 아카이브가 완료되었는지를 확인.
    2. 1단계에서 다음 리두 로그 그룹의 체크포인트와 아카이브 모드에서 아카이브가 완료되지 않았다면 완료될 때까지 대기한다.
    3. 로그 스위치 직전의 SCN을 리두 로그 파일 헤더에 기록한다.
    4. 새로운 리두 로그 그룹의 모든 멤버를 오픈하고 시퀀스 번호를 부여한다. 이 시점부터 새로운 로그 그룹이 Current가 된다.
    5. 이전 리두 로그 그룹은 ACTIVE로 표시하며 이전 리두 로그 파일에 대해 체크포인트를 수행한다. 체크포인트가 완료되면 INACTIVE로 표시한다.
    6. 데이터베이스가 아카이브 로그 모드라면 이전 리두 로그 그룹에 대한 아카이브를 시작한다.

- SCN(System Change Number)
  - SCN은 데이터베이스의 변경이 발생한 시점을 알려주는 데이터베이스 내부 시계와 같은 역할을 수행한다. 
  - 오라클은 데이터베이스에 변경이 발생할 때마다 SCN을 리두 로그 파일 헤더, 데이터파일 헤더 및 컨트롤 파일 헤더에 기록한다. 
  - 데이터베이스 기동 시 SCN을 기록한 리두 로그 파일 헤더, 데이터 파일 헤더 및 컨트롤 파일 헤더의 SCN이 일치하지 않으면 데이터베이스가 오픈되지 않는다.

- 리두 로그 파일의 상태

항목|내용
:---:|---
UNUSED|한 번도 사용하지 앟는 리두 로그 파일
ACTIVE|Current 리두 로그 파일의 기록이 종료한 후 Next 리두 로그 파일이 Current 리두 로그 파일이 되면<br> 기존의 Current 로그 파일은 체크포인트를 수행하며 체크포인트가 종료 될 때까지 ACTIVE 상태로 유지
INACTIVE|ACTIVE 상태인 리두 로그 파일의 체크포인트가 종료하면 INACTIVE 상태로 변경
CURRENT|현재 로그가 기록되는 리두 로그 파일

- 리두 로그 파일의 최소 조건
  - 최소한 두개의 리두 로그 그룹 졵
  - 각 그룹은 한 개 이상의 멤버 존재
  - 리두 로그 그룹은 순환 구조
  - 리두 로그 그룹은 로그 시퀀스 번호를 가지며 해당 시퀀스 번호는 로그 스위치가 발생할 때마다 1씩 증가

### 2) 리두 로그 파일의 장애
- 오라클은 리두 로그 그룹 안에 존재하는 하나의 멤버라도 장애가 발생하면 비정상 종료되며 이를 복구하기 전에는 정상 기동이 불가하다.
- 발생할 수 있는 장애 유형
  - 사용자 실수로 리두 로그 파일 삭제
  - 디스크 장애로 리두 로그 파일 손상

<img src=https://t1.daumcdn.net/cfile/tistory/275A783354FA050F2E />

- 위 그림을 확인해 보면 리두 로그 그룹 내의 각각 리두 로그 멤버는 다른 디스크에 위치하고 있다. 
- 이와 같이 구성하는 이유는 동일 디스킁게 특성 리두 로그 그룹의 모든 리두 로그 멤버를 같이 저장할 경우<br> 디스크 장애시 모든 리두 로그 멤버가 손실 되기 때문

#### 리두 로그 멤버와 성능저하
- 복구에 중점을 두어 하나의 리두 로그 그룹에 많은 멤버를 생성한 경우에는 동시에 기록해야할 멤버의 증가로 디스크 I/O가 발생해 성능 저하의 원인

## 02 리두 로그 파일의 관리
### 1) 리두 로그 파일의 확인
리두 로그 그룹 정보 확인

     SQL> SELECT * FROM V$LOG;
<br>

#### 추출되는 컬럼들
컬럼 명|내용
:---:|---
GROUP#||데이터베이스에 존재하는 리두 로그 그룹의 번호
THREAD#|해당 리두 로그 그룹의 인스턴스 번호 오라클 RAC가 아니라면 1로 추출
SEQUENCE#|리두 로그 그룹에 할당된 로그 시퀀스 번호
BYTES|리두 로그 그룹의 크기
MEMBERS|리두 로그 그룹에 존재하는 로그 멤버의 수 
ARCHIVED|아카이브 로그 모드일 경우 리두 로그 파일의 아카이브가 완료되었는지의 여부
STATUS|리두 로그 그룹의 상태
FIRST_CHANGE#|해당 리두 로그 그룹에서 가장 낮은 SCN 번호(Low SCN) 
FIRST_TIME|해당 리두 로그 그룹이 처음 사용된 시간

<br>

#### STATUS 컬럼이 가질 수 있는 값
STATUS 컬럼 값| 내용
:---:|---
UNUSED|리두 로그 그룹이 생성된 후 한 번도 사용하지 않은 상태
CURRENT|Current 리두 로그 그룹
ACTIVE|로그 스위치 등이 발생하여 체크포인트 수행 또는 복구 중인 상태
INACTIVE|해당 리두 로그 그룹이 Current 리두 로그 그룹이 아니며 비활동 중인 상태
CLEARING|리두 로그 그룹이 클리어(Clear)가 진행 중인 상태
CLEARING_CURRENT|Current 리두 로그 그룹에 클리어(Clear)가 진행 중인 상태

<br>

#### 리두 로그 멤버의 개수와 크기
- 실제 운영에서 관리의 용이성을 위해 리두 로그 그룹별 리두 로그 멤버의 수와 크기를 동일하게 생성할 것을 권장

리두 로그 멤버 정보 확인
        
    SQL> SELECT * FROM V$LOGFILE;
<br>

#### 추출되는 컬럼들
컬럼 명|내용
:---:|---
GROUP#|리두 로그 멤버가 속해있는 리두 로그 그룹 번호
STATUS|리두 로그 멤버의 상태
TYPE|리두 로그 파일의 종류(ONLINE 또는 STANDBY)
MEMBER|리두 로그 파일의 위치와 이름
IS_RECOVERY_DEST_FILE|플래쉬백 복구(Flash Recovery) 영역에 리두 로그 멤버가 존재하는지 여부

<br>

#### STATUS 컬럼이 가질 수 있는 값
STATUS 컬럼 값|내용
:---:|---
INVALID|리두 로그 멤버에 접근할 수 없는 상태
STALE|리두 로그 멤버의 내용이 불완전한 상태
DELETED|리두 로그 멤버가 더 이상 사용되지 않는 상태
공란|현재 사용중인 리두 로그 멤버

### 2) 리두 로그 그룹 추가
다음과 같은 명령으로 리두 로그 그룹을 추가할 수 있다.
    
    SQL> ALTER DATABASE ADD LOGFILE [GROUP n]
         ('file_name',['file_name']....) SIZE n
         [, [GROUP n] ('file_name',['file_name']...) SIZE n ...];

#### 제공되는 옵션
옵션|내용
:---:|---
GROUP n|리두 로그 그룹의 번호
file_name|리두 로그 파일의 이름
SIZE n|리두 로그 파일의 크기

### 3) 리두 로그 그룹 삭제
리두 로그 그룹 삭제 명령

    SQL> ALTER DATABASE DROP LOGFILE GROUP 6;
    
#### 리두 로그 그룹 삭제시 주의사항
항목|내용
:---:|---
리두 로그 그룹의 삭제|앞의 SQL을 사용하면 리두 로그 그룹 6은 데이터 딕셔너리에서 삭제는 되지만, 실제 리두 로그 파일은 삭제되지 않는다. <br>따라서 앞의 SQL 사용후 운영체제 명령으로 리두 로그 파일을 삭제해야한다.
리두 로그 파일의 상태|리두 로그 파일이 CURRENT 또는 ACTIVE 상태이면 제거가 불가능하다. INACTIVE 상태로 변경될 때까지 기다려야 한다.<br>또는 강제로 로그 스위치를 발생시켜 ACTIVE -> INACTIVE가 될 때까지 삭제 작업을 대기해야한다.

### 4) 리두 로그 멤버 추가
다음의 SQL로 리두 로그 멤버를 추가할 수 있다.

    SQL> ALTER DATABASE ADD LOGFILE MEMBER
         'file_name' [REUSE] [,'file_name' [REUSE] ...] TO GROUP n
         [,'file_name' [REUSE] [,'file_name' [REUSE] ...] TO GROUP n...];

#### 제공되는 옵션
옵션|내용
:---:|---
file_name|추가할 리두 로그 파일의 이름
REUSE|추가할 리두 로그 파일과 동일한 파일이 해당 파일 시스템에 조재할 경우 해당 파일을 재사용
GROUP n|리두 로그 멤버가 추가될 리두 로그 그룹 번호

### 5) 리두 로그 멤버 삭제
리두 로그 멤버 삭제도 리두 로그 그룹 삭제와 마찬가지로 오라클 명령으로는 운영체제에서 삭제되지 않으므로<br> 오라클 명령 수행 후 rm등의 운영체제 명령으로 파일을 삭제해야 한다.

    SQL> ALTER DATABASE DROP LOGFILE MEMBER '/data3/redo03c.log';

### 6) 리두 로그 그룹 초기화
- 리두 로그 파일이 손상되었을 경우 해당 리두 로그 파일을 삭제하고 추가해야 한다. 초기화 명령어는 로그 파일 삭제-추가를 한번에 해준다. 
- 다음의 경우에 유용하게 사용할 수 있다. 
  - CURRENT 리두 로그 그룹이 손상된 경우
  - 리두 로그 그룹이 오직 두개만 존재할 경우
- 리두 로그 그룹 초기화 명령어로는 파일의 위치나 개수 및 크기를 변경할 수 없다. 

#### 제공되는 옵션
옵션|내용
:---:|---
UNARCHIVED|아카이브 로그 모드에서 아카이브가 수행되지 않은 리두 로그 파일을 초기화할 경우 사용
GROUP n|초기화할 리두 로그 그룹 번호

    SQL> ALTER DATABASE CLEAR LOGFILE GROUP 2;
    SQL> ALTER DATABASE CLEAR LOGFILE UNARCHIVED GROUP 2;

- 아카이브가 수행되지 않은 리두 로그 그룹은 초기화가 안되지만, 초기화를 해야할 경우 UNARCHIVED 옵션을 사용할 수 있다. 
- 아카이브가 수행되지 않고 초기화된 리두 로그 파일은 복구에 사용할 수 없으므로 주의해야 한다.

## 03 아카이브 로그(Archive Log)의 개념
### 1) 노아카이브 로그 모드와 아카이브 로그 모드의 개념
구분|내용
:---:|---
노아카이브 로그 모드|리두 로그 파일을 별도로 보관하지 않는 모드
아카이브 로그 모드 |리두 로그 파일을 별도로 보관하는 모드
<br>

<img src=https://t1.daumcdn.net/cfile/tistory/254DE34854FA065F32 />

- 리두 로그 파일 내의 숫자는 로그 시퀀스 번호이다. 데이터베이스를 생성하면 기본적으로 노아카이브 로그 모드이다.

#### 노아카이브 로그 모드의 특징
- 로그 스위치 시 이전 리두 로그 그룹에 대해 체크포인트 발생
- 체크포인트가 종료된 리두 로그 그룹은 재사용 가능

#### 아카이브 로그 모드의 특징
- 로그 스위치 시 이전 리두로그 그룹에 대해 체크포인트 및 아카이브 발생
- 체크포인트와 아카이브가 종료된 리두 로그 그룹에 대해서 재사용 가능
- 리두 로그 그룹이 순환되어 이전 정보가 삭제되어도 다른 복사본(아카이브)을 가지고 있으므로 지워진 리두 로그 정보가 보존된다.

#### 아카이브와 백그라운드 프로세스
- 로그 스위치 발생 시 리두 로그 파일을 아카이브 로그의 저장 위치로 복사하는 역할은 ARCH 프로세스가 수행

### 2) 노아카이브 로그 모드와 아카이브 로그 모드의 장점과 단점

<img src=https://t1.daumcdn.net/cfile/tistory/2777674054FA05B830 />

항목|장점|단점
:---:|---|---
아카이브 로그 모드|- 복구 시점 조절 가능<br>- 온라인 복구 가능<br>- 온라인 백업 가능|- 백업 및 복구 복잡<br>- 디스크 I/O 증가
노아카이브 로그 모드|- 백업 및 복구 단순<br>- 디스크 I/O 감소|- 복구 시점 조절 불가<br>- 온라인 복구 불가<br>- 온라인 백업 불가

#### 노 아카이브 로그 모드의 장점
항목|내용
:---:|---
백업 및 복구<br>방법 단순|노아카이브 로그 모드에서의 백업은 데이터에비스를 종료한 상태에서<br> 데이터 파일, 리두 로그 파일 및 컨트롤 파일을 운영체제 명령을 이용하여 복사
디스크 I/O 감소|아카이브를 수행하기 위한 리두 로그 파일 복사와 관련된 디스크 I/O가 존재하지 않음

#### 노 아카이브 로그 모드의 단점
항목|내용
:---:|---
온라인 백업 불가|노아카이브 로그 모드의 백업과 복구는 반드시 데이터베이스를 종료하고 진행해야 한다. 이는 서비스에 영향을 미친다
백업 받은 시점까지만 복구 가능|데이터베이스의 변경 내용을 저장하는 리두 로그 파일을 적용할 수 없기 때문에 백업 받은 시점으로 데이터베이스가 복구된다.<br> 데이터 유실이 발생할 수 있다.
온라인 복구 불가|테이블스페이스 장애시 데이터베이스는 비정상 종료되며 데이터베이스 오픈 상태에서 복구가 불가능하다.

#### 아카이브 로그 모드의 장점
항목|내용
:---:|---
온라인 백업 가능|오라클은 아카이브 로그 모드일 경우에만 온라인 백업이 가능하다. 서비스를 계속 유지할 수 있다.
복구 시점 조절 가능|모든 리두 로그 파일을 보관하고 있으므로 장애가 발생했을 경우 원하는 시점으로 복구 가능하다.
온라인 복구 가능|테이블스페이스 장애 시 다른 테이블스페이스를 사용하는 서비스는 정상이며 데이터베이스 오픈 상태에서 복구 가능하다. 시스템 테이블 스페이스 장애시에는 복구가 불가능하다.

#### 아카이브 모드에서의 복구 과정
1. 데이터베이스 장애가 발생하면 온라인 백업 파일을 정해진 위치에 복원한다.
2. 아카이브된 리두 로그 파일과 Current 리두 로그 파일을 이용하여 리두 로그 정보를 백업파일 시점 이후로 차례대로 적용한다.
3. 데이터 손실 없이 장애 발생 시점(또는 원하는 시점)까지 데이터베이스를 복구할 수 있다.

#### 아카이브 로그 모드의 단점
항목|내용
:---:|---
노아카이브 로그 모드에<br>비해 복잡한 백업 및 복구|cp와 같은 운영체제 명령어로 복구화는 노아카이브 로그 모드와 달리 아카이브 로그 파일에 대한 백업 및 적용에 대해 고려해야하므로 다소 복잡하다.
아카이브에 의한 추가적인 디스크<br>I/O 발생 및 데이터베이스 행 주의|아카이브 파일 복사 및 엑세스 등은 추가적인 디스크 I/O가 발생한다. 대략 2~3% 정도의 부하에 해당될 수 있다. 

#### 데이터베이스 행이란?
1. 아카이브 로그 모드에서는 리두 로그 그룹이 순환할 경우 새로 사용할 리두 로그 그룹의 아카이브가 완료 될 때까지 대기
2. 아카이브가 완료될 때까지 리두 로그 버퍼의 변경 로그를 기록할 수 없음
3. LGWR 프로세스가 리두 로그 버퍼의 내용을 디스크의 리두 로그 파일에 기록할 수 없으므로 데이터베이스 행(Hang) 현상이 발생한다.
4. 어떠한 DML 작업도 로그를 기록할 수 없으므로 수행이 불가능한 상태가 된다.
5. 새로 사용할 리두 로그 그룹의 아카이브가 완료되면 리두 로그 버퍼에 로그를 파일에 기록할 수 있으므로 다시 데이터베이스 사용가능

## 04 아카이브 로그 모드의 설정 및 해제
### 1) 아카이브 로그 모드 설정
- 아카이브 로그 모드 설정 절차
  1. 아카이브 로그 모드 및 노아카이브 로그 모드를 설정하기 위해서는 데이터베이스가 마운트 상태여야 한다. 운영 중이라면 종료 한다.
  2. 데이터베이스를 종료 후 아카이브 로그 모드 관련 파라미터를 설정한다.
  3. 데이터베이스를 마운트 단계로 기동시킨다.
  4. 데이터베이스를 아카이브 로그 모드로 변경한다.
  5. 데이터베이스를 오픈한다.

<br>

#### 아카이브 로그 모드 관련 파라미터
파라미터|내용
:---:|---
LOG_ARCHIVE_DEST|아카이브 로그 파일이 저장될 위치, LOG_ARCHIVE_DEST_n 파라미터와 같이 사용 불가
LOG_ARCHIVE_DEST_n|LOG_ARCHIVE_DEST와 마찬가지로 아카이브 로그 파일이 저장될 위치를 지정하는 파라미터, 한곳 이상 다중으로 지정 가능
LOG_ARCHIVE_DEST_STATE_n|LOG_ARCHIVE_DEST_n 파라미터와 같이 사용하며 지정된 위치에 파일의 저장 방식 설정
LOG_ARCHIVE_DUPLEX_DEST|아카이브 로그 파일이 저장될 위치를 지정하며 아카이브 로그 파일을 두 곳에 저장할 때 사용한다.
LOG_ARCHIVE_FORMAT|아카이브 로그 파일의 이름 형식을 지정
LOG_ARCHIVE_MAX_PROCESSES|ARCH 백그라운드 프로세스의 수를 지정, 1~30 지정 가능, 기본 4
LOG_ARCHIVE_MIN_SUCCEED_DEST|아카이브 로그 파일을 여러 곳에 지정할 때 반드시 저장에 성공해야 할 아카이브 로그 파일의 수 지정
LOG_ARCHIVE_TRACE|아카이브 로그 파일을 지정된 위치에 저장할 경우 alertSID.log 파일에 추적 로그를 기록하는 파라미터, 기본 값은 0으로 추적하지 않음
LOG_ARCHIVE_START|데이터베이스를 기동하면 ARCH 프로세스가 자동을 활동하게 설정

#### LOG_ARCHIVE_DEST_STATE_n 파라미터
- LOG_ARCHIVE_DEST_n 과 짝을 이루는 파라미터, 예를 들어 LOG_ARCHIVE_DEST_1 파라미터에 대한 짝은 LOG_ARCHIVE_DEST_STATE_1

#### LOG_ARCHIVE_DEST_STATE_n에 설정할 수 있는 옵션
옵션|내용
:---:|---
ENABLED|ENABLE로 설정된 모든 짝을 이루는 아카이브 로그 파일은 LOG_ARCHIVE_DEST_n에 아카이브 로그 파일을 반드시 저장한다.
DEFFER|DEFFER로 설정된 모든 짝을 이루는 아카이브 로그 파일은 LOG_ARCHIVE_DEST_n에 아카이브 로그 파일을 저장하지 않는다.
ALTERNATE|ENABLE로 설정된 모든 짝을 이루는 아카이브 로그 파일은 LOG_ARCHIVE_DEST_n에 아카이브 로그 파일을 반드시 저장해야한다<br> 하지만 저장에 실패했을 경우에는 ALTERNATE (ex, ALTERNATE=LOG_ARCHIVE_DEST_2) 로 설정된 위치에 저장한다.

#### LOG_ARCHIVE_DEST_STATE_n 및 LOG_ARCHIVE_DEST_n
- 아카이브 로그를 다중으로 관리하고자 한다면 해당 파라미터를 이용하겠으나 보통의 경우에는 아카이브 로그 파일은 하나만을 복사하므로<br>LOG_ARCHIVE_DEST 파라미터로 하나의 파일 시스템에만 복사하고, 일정 기준에 의해 테이프로 복사한 후 삭제해도 충분하다.

#### LOG_ARCHIVE_FORMAT에 설정할 수 있는 값
값|내용
:---:|---
%s|로그 시퀀스 번호
%S|로그 시퀀스 번호이며 앞부분을 0으로 채워 동일한 길이로 표현
%t|쓰레드 번호
%T|쓰레드 번호이며 앞부분을 0으로 채워 동일한 길이로 표현
%a|활동 아이디
%d|데이터베이스 아이디
%r|리셋 로그 아이디, 리셋 로그 옵션을 사용하면 시퀀스 번호가 1부터 새로 할당 되므로 리셋 로그 아이디로 파일명 중복 방지

#### 리셋 로그(Resetlog)와 불완전 복구

    아카이브 로그 모드로 운영 중인 데이터베이스에 대해 장애가 발생하여 장애 발생 시점이 아닌 과거 특정 시점까지만 복구하는
    불완전 복구를 수행했다고 가정하자. 불완전 복구를 수행하면 리셋 로그 명령어를 사용하게 되며, 해당 명령어를 사용하면
    로그 시퀀스 번호는 초기화가 된다. 따라서 리셋 로그 후에는 로그 시퀀스 번호가 1부터 할당된다.

- LOG_ARCHIVE_FORMAT 
  - 아카이브 로그 파일의 이름에 로그 시퀀스 번호, 쓰레드 번호 및 리셋로그 아이디가 포함되어야 한다.
  
#### 아카이브 로그 모드로 변경

    SQL> STARTUP MOUNT
    SQL> ALTER DATABASE ARCHIVELOG;
    Database altered.
    SQL> ALTER DATABASE OPEN;

### 2) 다중 아카이브 로그 파일 설정
<img src=https://t1.daumcdn.net/cfile/tistory/225B044254FA05BA08 />

- 다중 아카이브 로그 파일의 목적
  - 저장 매체 장애로 아카이브 로그 파일 손실 방지
  - 사용자 실수에 의한 아카이브 로그 파일 손실 방지
    - 이전 리두 로그 파일에 대해 아카이브가 불가능하면 리두 로그 그룹 순환시 데이터베이스 행을 유발할 수 있음.

- 다중 아카이브 로그 파라미터
  - LOG_ARCHIVE_DEST 파라미터와 LOG_ARCHIVE_DUPLEX_DEST
  - LOG_ARCHIVE_DEST_n

아카이브 파일을 두 곳에만 저장할 때

    LOG_ARCHIVE_DEST = /data1/ARCH
    LOG_ARCHIVE_DUPLEX_DEST = /data2/ARCH


LOG_ARCHIVE_DEST_n 파라미터를 사용하면 아카이브 로그 파일을 10곳까지 저장 가능

    LOG_ARCHIVE_DEST_[1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10]=
    { LOCATION=path_name | SERVICE=service_name }
    [ { MANDATORY | OPTIONAL } ]
    [ REOPEN[=seconds] | NOREOPEN ]

#### LOG_ARCHIVE_DEST_n에 설정할 수 있는 옵션
옵션|내용
:---:|---
LOCATION|아카이브 로그 파일이 저장될 로컬 시스템 위치
SERVICE|아카이브 로그 파일을 저장할 원격 시스템 이름,<br> (원격 시스템 이름은 $ORACLE_HOME/network/admin/tnsnames.ora 파일에 기록되어 있어야 함)
MANDATORY|아카이브 로그 파일이 지정된 위치에 반드시 저장되어야 함
OPTIONAL|아카이브 로그 파일이 지정된 위치에 저장되지 않아도 됨
REOPEN|아카이브 로그 파일을 지정된 위치에 저장하는데 실패할 경우 재시도 간격 설정, 기본값 300초 설정 단위는 초 횟수는 제한 없음

#### LOG_ARCHIVE_DEST_n 파라미터 사용법.
- 다음 예제는 3곳에 아카이브 로그 파일을 저장하는 예이다.

대상 로그 파일|요구 사항
:---:|---
첫 번째 아카이브 로그 파일|로컬 시스템 /data1/ARCH에는 반드시 아카이브 로그를 저장하며 저장 실패시 600초마다 재시도
두 번째 아카이브 로그 파일|로컬 시스템 /data1/ARCH에 저장
세 번째 아카이브 로그 파일|원격 데이터베이스에 저장

위의 요구사항에 맞게 LOG_ARCHIVE_DEST_n 파라미터 설정

    LOG_ARCHIVE_DEST_1 = "LOCATION=/data1/ARCH/ MANDATORY REOPEN = 600"
    LOG_ARCHIVE_DEST_2 = "LOCATION=/data2/ARCH/ OPTIONAL"
    LOG_ARCHIVE_DEST_3 = "SERVICE=arch_back OPTIONAL"

#### 아카이브 로그 저장을 위한 파일 시스템 공간 부족
- 아카이브 로그를 저장하는 파일 시스템 공간이 부족하게 되면 리두 로그 파일에 대해 더 이상 아카이브 로그를 저장할 수 없게 된다.
- 이 경우에는 데이터베이스 행이 발생하므로 해당 아카이브 로그를 저장하는 파일시스템에서 불필요한 아카이브 로그를 삭제해야 
- 한다.

### 3) 아카이브 로그 모드 해제
아카이브 로그 모드 해제

    SQL> STARTUP MOUNT
    SQL> ALTER DATABASE NOARCHIVELOG;
    Database altered
    SQL> ALTER DATABASE OPEN;

## 05 아카이브 로그 모드의 관리
<img src=https://t1.daumcdn.net/cfile/tistory/265CB34254FA05BB07 />

### 1) Current 리두 로그 그룹의 수동 아카이브
Current 리두 로그 그룹을 아카이브해야 할 필요가 있는 경우 다음과 같은 명령으로 아카이브를 수행할 수 있다.

    SQL> ALTER SYSTEM ARCHIVE LOG CURRENT;
    해당 명령어는 로그 스위치를 발생시키며 Current 리두 로그 그룹에 체크포인트와 아카이브가 실행된다.

### 2) 아카이브 로그 모드 정보 검색
다음 명령어를 통해 데이터베이스가 아카이브 로그 모드인지 또는 노아카이브 로그 모드인지 확인할 수 있다.

    SQL> ARCHIVE LOG LIST

    Database log mode Archive Mode 
    Automatic archival Enabled
    Archive destination /data1/ARCH/
    Oldest online log sequence 35
    Next log sequence to archive 37
    Current log sequence 37

#### 결과 값 항목의 의미
항목|내용
:---:|---
Database log mode|데이터베이스가 아카이브 로그 모드인지 노아카이브 로그 모드인지 여부
Autometic archival|데이터베이스 기동시 ARCH 프로세스 자동 기동 또는 수동 기동 여부
Archive destination|아카이브 로그 파일이 저장되는 위치
Oldest online log sequence|리두 로그 그룹 중 가장 작은 로그 시퀀스 번호
Next log sequence to archive|로그 스위치 발생 시 아카이브가 수행될 리두 로그 그룹의 로그 시퀀스 번호
Current log sequence|Current 리두 로그 그룹의 로그 시퀀스 번호

데이터베이스의 수행된 아카이브 로그 이력 검색

    SQL> SELECT DEST_NAME, NAME, SEQUENCE#, B.STATUS
           FROM V$ARCHIVE_DEST A, V$ARCHIVED_LOG B
          WHERE A.DEST_ID = B.DEST_ID;

<br>

#### 추출되는 컬럼의 의미
항목|내용
:---:|---
DEST_NAME| 아카이브 로그 파일이 저장된 위치
NAME| 아카이브 로그 파일 이름
SEQUENCE#| 아카이브 로그 파일의 로그 시퀀스 번호
STATUS| 아카이브 로그 파일의 상태

#### STATUS 컬럼에 저장될 수 있는 값
값|내용
:---:|---
A|사용 가능
D|삭제
U|사용 불가능
X|기한 만료